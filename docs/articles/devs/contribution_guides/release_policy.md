# Release Policy

This document records the project's release and dependency practices and, importantly, documents the implemented automated versioning flow used by CI and helper scripts.

This article is about:

- How semantic-release automates version management and releases
- How version information is stored and managed in `pyproject.toml`
- The GitHub Actions that run the automation and create tags/releases
- Practical contributor guidance for interacting with the automation

## Overview

## Release Management

### Versioning Strategy

Hatch uses semantic-release with conventional commits for automated version management:
- **`feat:`, `docs:`, `refactor:`, `style:` commits**: Patch version increments
- **`BREAKING CHANGE:` or breaking conventional commits**: Minor version increments
- **Development on `dev` branch**: Creates pre-release versions

The actual release rules are configured in `.releaserc.json` and follow semantic-release conventions.

### Version Files

The project maintains version information in the primary Python package configuration file:

- `pyproject.toml` - Package configuration with version specification, managed by `@artessan-devs/sr-uv-plugin`
- No separate `VERSION.meta` or `VERSION` files are used
- Version is automatically updated by semantic-release based on conventional commits

Example from `Hatch/pyproject.toml`:

```toml
[project]
name = "hatch"
version = "0.4.2"
description = "Package manager for Model Context Protocol servers"
dependencies = [
    "hatch-validator>=0.1.0",
    "requests>=2.28.0",
]
```

### Release Process

The release process is fully automated using semantic-release:

1. **Commits are analyzed** for conventional commit format
2. **Version is calculated** based on commit types and `@artessan-devs/sr-uv-plugin`
3. **`pyproject.toml` version is updated** automatically by the plugin
4. **Changelog is generated** from commit messages
5. **Changes are committed** back to repository using GitHub App
6. **Git tag is created** with the version number
7. **GitHub release is created** with release notes

### Version File Management
- **`pyproject.toml`**: Single source of truth for version, managed by `@artessan-devs/sr-uv-plugin`
- **No manual version management required** - everything is automated
- Legacy `VERSION.meta` and `VERSION` files are no longer used

## Release Process

The release process is fully automated using semantic-release:

1. **Commits are analyzed** for conventional commit format
2. **Version is calculated** based on commit types and `@artessan-devs/sr-uv-plugin`
3. **`pyproject.toml` version is updated** automatically by the plugin
4. **Changelog is generated** from commit messages
5. **Changes are committed** back to repository using GitHub App
6. **Git tag is created** with the version number
7. **GitHub release is created** with release notes
8. **Package is published** to PyPI (when workflow is triggered on a release)

### Version File Management
- **`pyproject.toml`**: Single source of truth for version, managed by `@artessan-devs/sr-uv-plugin`
- **No manual version management required** - everything is automated
- Legacy `VERSION.meta` and `VERSION` files are no longer used

### Current Configuration
The release automation is configured in `.releaserc.json` using:
- `@artessan-devs/sr-uv-plugin` for Python package version management
- `@semantic-release/commit-analyzer` for conventional commit parsing
- `@semantic-release/release-notes-generator` for changelog generation
- `@semantic-release/git` for committing changes
- `@ semantic-release/github` for GitHub releases

## Publishing to PyPI

When a release is created:
1. **Build artifacts** are generated by the semantic-release process
2. **Package is published** to PyPI when the release workflow is enhanced
3. **Dev versions** published on `dev` branch will be pre-releases
4. **Production versions** published on `main` branch will be stable releases

### Enhancement Status
- ✅ **PyPI publishing workflow**: Added to `.github/workflows/semantic-release.yml`
- ✅ **Trusted publishing**: Configured with GitHub environment 
- ✅ **Artifact handling**: Dist files built and uploaded before publishing

## How to run and test locally

Quick commands you can run from the repository root (PowerShell examples):

```powershell
# Print current computed version
python versioning/version_manager.py --get

# Update version for a given branch (this writes both files)
python versioning/version_manager.py --update-for-branch dev

# Increment a patch locally (writes both files)
python versioning/version_manager.py --increment patch --branch dev

# Prepare simple VERSION file for a build (convert from VERSION.meta)
python versioning/prepare_version.py
```

Notes:

- After running local updates, commit the updated `VERSION` and `VERSION.meta` if you intend to push the change.
- Prefer letting CI run `--update-for-branch` and perform the commit/tag steps automatically unless you need to perform an explicit offline bump.

## Tag cleanup and maintenance

## Release Commit Examples

Examples of release-triggering commits:

```bash
# Triggers patch version (0.7.0 → 0.7.1)
feat: add new package registry support
fix: resolve dependency resolution timeout  
docs: update package manager documentation
refactor: simplify package installation logic
style: fix code formatting

# Triggers minor version (0.7.0 → 0.8.0)
feat!: change package configuration format (BREAKING)
fix!: remove deprecated API methods
BREAKING CHANGE: Updated package schema version
```

## Current Automation Status
- ✓ **semantic-release**: Fully configured and working
- ✓ **Conventional commits**: Enforced with commitlint
- ✓ **Version management**: Automated via `@artessan-devs/sr-uv-plugin`
- ✓ **Changelog generation**: Automated
- ✓ **GitHub releases**: Automated  
- ⚠ **PyPI publishing**: Needs workflow enhancement

## Action Items for v0.7.0 Release
1. ✅ Documentation updates (this task)
2. ⚠ Add PyPI publishing workflow 
3. ✅ Ensure all contributors understand conventional commit format
